{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RIT Racing Electronics Documentation","text":"<p> Welcome to the RIT Racing Electronics Documentation! This source serves as a reference for members participating in the electronics group at RIT Racing. It contains guides for getting started, electronics concepts, source code documentation, and the underlying technology involved in electronics engineering and embedded development at RIT Racing.</p> <p>Since this documentation is open source, feel free to contribute additional concepts and material that you believe will enhance the knowledge of RIT Racing's electronics engineers.</p>"},{"location":"Contribute/contribute/","title":"Contribute","text":"<p>To contribute, follow the steps below:</p> <p>Documentation repository: https://github.com/RITRacingSoftware/RITRacingSoftware.github.io</p> <p>(1) Fork the documentation repository. (A Github account is required)</p> <p>(2) Clone the repository.</p> <pre><code>git clone https://github.com/&lt;Your_Github_Username&gt;/RITRacingSoftware.github.io\n\ncd RITRacingSoftware.github.io/\n</code></pre> <p>(3) Create or update documentation.</p> <ul> <li>Material for MkDocs follows a directory based layout for routing to pages within a sites documentation (found in <code>docs/</code>). This means that a directory creates a new folder and any files within the folder will show up as pages on the site.</li> </ul> <pre><code>Example Site layout\n\u251c\u2500\u2500 docs\n\u2502   \u251c\u2500\u2500 Hardware\n\u2502   \u2502   \u2514\u2500\u2500 MCU.md\n\u2502   \u251c\u2500\u2500 index.md\n\u2502   \u251c\u2500\u2500 Firmware\n\u2502   \u2502   \u2514\u2500\u2500 index.md\n\u2502   \u2514\u2500\u2500 stylesheets\n\u2502       \u2514\u2500\u2500 extra.css\n</code></pre> <ul> <li>To include any graphical assets, add an image to the desired folder and refer to it within any markdown file through the following directive. HTML is preferred as images can be easily centered without fuss</li> </ul> <pre><code>&lt;div style=\"text-align: center;\"&gt;\n    &lt;img src=\"assets/image_name.png\" alt=\"alt text\" /&gt;\n&lt;/div&gt;\n</code></pre> <p>(4) Once you have finished adding docmentation push the changes to your accounts repositories and click the <code>Contribute</code> button to create a pull request.</p> <pre><code>git add docs/info/myfile.md\ngit commit -m \"create more documentation\"\ngit push\n</code></pre>"},{"location":"Firmware/","title":"Firmware","text":""},{"location":"Firmware/#getting-started","title":"Getting started","text":"<p>Users will generally have a directory on their system containing one copy of  the Core, one copy of STM32G4 HAL, and one copy of the FreeRTOS kernel on  their system. Each project they create will then use these libraries when  compiling. It is recommended to have the following directory structure on your system:</p> <pre><code>RITRacing\n\u251c\u2500\u2500 core\n\u251c\u2500\u2500 Formula-DBC\n\u251c\u2500\u2500 FreeRTOS-Kernel\n\u251c\u2500\u2500 RTT\n\u251c\u2500\u2500 STM32CubeG4\n\u251c\u2500\u2500 &lt;project1&gt;\n\u251c\u2500\u2500 &lt;project2&gt;\n\u2514\u2500\u2500 &lt;etc.&gt;\n</code></pre> <p>Where precisely this folder will be located will depend on your system and personal preferences.</p>"},{"location":"Firmware/#coding-style","title":"Coding Style","text":"<p>There is no official \"style guide\" for RITRacing. However, you do have to set your tabs to 4 spaces.</p>"},{"location":"Firmware/#navigation","title":"Navigation","text":"<p>All of our installation and compilation will be done with terminal commands. The terminal is just another way to navigate your computer's file system and interact with the programs and files you have. If you're not already comfortable using the terminal you should review the Terminal page.</p>"},{"location":"Firmware/#installing-the-prerequisites","title":"Installing the prerequisites","text":"<p>To compile code for an STM32 on your computer, a cross-compiler toolchain is required. On Linux, the required packages can be installed directly to your system or in a Docker image. On MacOS, the required packages can be installed  directly to your system via Homebrew. On Windows, the toolchain is installed with Windows Subsystem for Linux.</p> <p>By the end of this you should have:</p> <ul> <li>Via pacakage manager:<ul> <li>openocd</li> <li>git</li> <li>make</li> <li>gcc-arm-none-eabi (Windows/Linux)</li> <li>gcc-arm-embedded (MacOS)</li> <li>gdb-multiarch (optional)</li> </ul> </li> <li>Via GitHub:<ul> <li>core</li> <li>Formula-DBC</li> <li>STM32CubeG4</li> <li>FreeRTOS-Kernel</li> <li>RTT</li> </ul> </li> </ul> <p>First, we will install the external dependencies handled by a package manager. This will vary depending on your system.</p>"},{"location":"Firmware/#linux","title":"Linux","text":"<p>If <code>apt</code> is present on your distribution, <code>git</code> and <code>openocd</code> can be installed with:</p> <pre><code>sudo apt install git openocd\n</code></pre> <p>For other distributions and installation options, see the official documentation for git and for openocd. You can also check your system's package manager for <code>git</code> and <code>openocd</code>.</p> <p>Similarly, the cross-compilation toolchain can be installed with:</p> <pre><code>sudo apt install gcc-arm-none-eabi gdb-multiarch\n</code></pre> <p>Some features of our flash script will require <code>telnet</code> as well.</p>"},{"location":"Firmware/#macos","title":"MacOS","text":"<p>To begin, you will need to install Homebrew, a package manager for MacOS. You can follow the instructions on their website, or you can paste the following command in your terminal:</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> <p>Once Homebrew is installed, you can begin to use it to install the necessary packages.</p> <p>Install the GCC embedded toolchain with:</p> <pre><code>brew install --cask gcc-arm-embedded\n</code></pre> <p>Then, install <code>openocd</code> with:</p> <pre><code>brew install open-ocd\n</code></pre> <p>Check to see if <code>git</code> is installed on your system with <code>git --version</code>. If <code>git</code> isn't present on your system already, it can be installed with:</p> <pre><code>brew install git\n</code></pre> <p>Check to see if <code>make</code> is installed on your system with <code>make --version</code>. If <code>make</code> isn't present on your system already, it can be installed with:</p> <pre><code>brew install make\n</code></pre>"},{"location":"Firmware/#windows","title":"Windows","text":"<p>To install the required software, you will need to install Windows Subsystem for Linux. You will not need Docker on Windows. </p> <p>Press the Windows key and search for \"Turn Windows features on or off\". Make  sure that the following options are turned on:</p> <ul> <li>Virtual Machine Platform</li> <li>Windows Hypervisor Platform</li> <li>Windows Subsystem for Linux</li> </ul> <p>You will need to run commands both in  Windows Powershell  and in  WSL . They will be denoted in this color coding.</p> <p> In Windows Powershell, run: </p> <pre><code>wsl --install\n</code></pre> <p>If a reboot is required, reboot your computer now.</p> <p> After the reboot, in Windows Powershell run: </p> <pre><code>wsl --install -d Ubuntu-22.04\n</code></pre> <p>You will be asked to set up a user with a password. Once you have created the user, you should be on the Linux terminal.</p> <p> If not, in Windows Powershell enter WSL by running: </p> <pre><code>wsl\n</code></pre> <p> In WSL, install packages by running: </p> <pre><code>sudo apt update\nsudo apt install git make gcc-arm-none-eabi gdb-multiarch openocd usbutils telnet\n</code></pre>"},{"location":"Firmware/#github-dependencies","title":"GitHub dependencies","text":"<p>The <code>RITRacing</code> directory containing the prerequisite libraries and code can be placed anywhere within the WSL filesystem, but place them all in the RITRacing directory. The following commands can be run on any OS, but if you are using Windows make sure to use WSL.</p>"},{"location":"Firmware/#external-dependencies","title":"External dependencies","text":"<p>These repositories weren't written by us, but are necessary for compilation.</p> <p>Install the STM32CubeG4 repository with:</p> <pre><code>git clone --recursive https://github.com/STMicroelectronics/STM32CubeG4.git\n</code></pre> <p>Install the FreeRTOS-Kernel repository with:</p> <pre><code>git clone --recursive https://github.com/FreeRTOS/FreeRTOS-Kernel.git\n</code></pre> <p>Install the RTT repository with:</p> <pre><code>git clone https://github.com/SEGGERMicro/RTT.git\n</code></pre>"},{"location":"Firmware/#internal-dependencies","title":"Internal dependencies","text":"<p>These repositories have been written by us:</p> <p>Install the core repository with:</p> <pre><code>git clone https://github.com/RITRacingSoftware/core.git\n</code></pre> <p>Install the Formula-DBC repository with:</p> <pre><code>git clone https://github.com/RITRacingSoftware/Formula-DBC.git\n</code></pre> <p>To configure the core library within your project, check out the core library docs</p>"},{"location":"Firmware/#setting-up-a-project","title":"Setting up a project","text":"<p>New projects are created from the STM32G4xx-Template template repository. Instructions for using the template can be found in the template's README. When cloning the new project to your computer, you should clone it to the same directory that contains the core and the HAL. If the  project is stored in any other location, the Makefile will need to be adjusted so the compiler can find the required libraries.</p> <p>For simple test code for the new member project, clone the STM32G4xx-Template repository with:</p> <pre><code>git clone https://github.com/RITRacingSoftware/STM32G4xx-Template.git\n</code></pre> <p>You can edit the code inside the template without creating another repository from it,  and it will have everything you need to get started.</p> <p>Alternatively, an existing project can be cloned from Github. For example, to clone the <code>core-vc</code> project, use the following command:</p> <pre><code>git clone https://github.com/RITRacingSoftware/core-vc.git\n</code></pre> <p>The instructions below will assume that you have <code>cd</code>'d into the project's directory.</p>"},{"location":"Firmware/#compiling-a-project","title":"Compiling a project","text":"<p>To compile a project, run the <code>make</code> command from the terminal. This command will generate a <code>.elf</code> binary image and a <code>.ihex</code> file.</p>"},{"location":"Firmware/#flashing-a-project","title":"Flashing a project","text":"<p>Compiled binaries are typically flashed in one of two ways. During development, this is most commonly done with a J-link programmer, which connects to your computer via USB. For boards in the car, this is typically done via MCan. In both cases, this can be done by running the script <code>./scripts/flash.sh</code>, which is located in the project repository. This script does four things:</p> <ol> <li>The script looks in the Makefile and determines the filename of the      compiled binary.</li> <li>The script tries to connect to an existing instance of <code>openocd</code> with     <code>telnet</code>. If this is possible, it commands <code>openocd</code> to upload the binary     and exits. This feature is useful if you are debugging a project with     RTT (as explained below) and you would like to upload without stopping     your RTT session.</li> <li>Next, it tries to connect to MCan. If this is possible, the binary is     uploaded with MCan and the script exits.</li> <li>Finally, the script invokes <code>openocd</code> to upload the binary.</li> </ol>"},{"location":"Firmware/#usb-passthrough","title":"USB passthrough","text":"<p>On Windows, a few additional steps are required to allow the J-link to be accessed by programs within WSL. All of the following commands should be run in  Windows Powershell, opened as an administrator .</p> <ol> <li> Run  <code>winget install --interactive --exact dorssel.usbipd-win</code> to install <code>usbipd</code>.</li> <li>Follow the prompts to install <code>usbipd</code>. Once the installation has      completed, close and reopen the PowerShell, again as administrator.</li> <li>Plug J-link into your computer</li> <li> Run  <code>usbsetup.cmd</code> in the <code>scripts</code> directory. You will have to re-run     this step every time the J-link is plugged in.</li> </ol>"},{"location":"Firmware/#usb-passthrough-alternative","title":"USB passthrough alternative","text":"<p>In the event that step 4 in the above list didn't work, the USB can be connected to WSL manually. Run the following steps instead of step 4, you do not need to repeat steps 1-3.</p> <ol> <li> In Windows Powershell run  <code>usbipd list</code>. Note the <code>BUSID</code> of the device <code>J-Link</code>.</li> <li> Run  <code>usbipd bind --busid &lt;busid&gt;</code>, replacing <code>&lt;busid&gt;</code> with the ID of your J-Link recorded in step 1.</li> <li> Run  <code>usbipd attach --wsl --busid &lt;busid&gt;</code>.</li> <li> In WSL, run  <code>lsusb</code>, and confirm the J-Link is attached.</li> </ol> <p>You can now flash by  running  <code>./scripts/flash.sh</code> in  WSL  from your parent project directory.</p>"},{"location":"Firmware/#debugging-a-project","title":"Debugging a project","text":"<p>There are several ways of debugging a program that is running on an STM32. The simplest is to use the <code>rprintf</code> function to print to a terminal on your computer. To use this function, you must include <code>rtt.h</code> in any file that uses it. Then, to see the printed messages, run the following command in a terminal window:</p> <pre><code>openocd -f rtt.cfg\n</code></pre> <p>This will start a server that you must connect to from another terminal window by running the command:</p> <pre><code>nc localhost 8888\n</code></pre> <p>Any output from <code>rprintf</code> calls in the program will then be displayed in the second terminal window.</p>"},{"location":"Firmware/#debugging-with-gdb","title":"Debugging with GDB","text":"<p>To use GDB to debug a program, start <code>openocd</code> as above:</p> <pre><code>openocd -f rtt.cfg\n</code></pre> <p>This will start a server that <code>gdb-multiarch</code> can connect to to debug the program. If <code>gdb-multiarch</code> is installed directly on your system (rather than in a docker image), then you can start the debugger by running <code>gdb-multiarch</code> with the path to the executable as its argument. For example, if your project is named <code>project1</code>, then the command is:</p> <pre><code>gdb-multiarch build/stm32/project1.elf\n</code></pre> <p>When this command is run, <code>gdb-multiarch</code> will run in interactive mode. Enter the following command to attach the <code>gdb-multiarch</code> to the board</p> <pre><code>target extended-remote localhost:3333\n</code></pre> <p>You can then use standard GDB commands to inspect the state of the program and the chip. See this document for an overview of GDB commands.</p>"},{"location":"Firmware/Terminal/","title":"Terminal","text":"<p>The terminal is a text-based way to interact with the files and programs on your computer. It is used extensively here at RITRacing, because it is very quick to use, integrated, and highly configurable. Here are some common terminal commands and a bit more about using it. On MacOS and Linux, navigate to the <code>Terminal</code> application and use that directly. For Windows, use the instructions in the main Firmware page to set up <code>WSL</code> and use  that terminal to run commands.</p>"},{"location":"Firmware/Terminal/#example-repository","title":"Example repository","text":"<p>This will be the example repository layout used as examples for the commands described in this page:</p> <pre><code>new-project\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 main\n\u2502   \u2502   \u251c\u2500\u2500 main.c\n\u2502   \u2502   \u2514\u2500\u2500 main.h\n\u2502   \u2514\u2500\u2500 driver\n\u2502       \u251c\u2500\u2500 driver.c\n\u2502       \u2514\u2500\u2500 driver.h\n\u251c\u2500\u2500 scripts\n\u2502   \u251c\u2500\u2500 flash.sh\n\u2502   \u2514\u2500\u2500 update_config.py\n\u2514\u2500\u2500 config.h\n</code></pre> <p>For all of the examples, expect to start in the <code>new-project</code> directory unless otherwise stated.</p>"},{"location":"Firmware/Terminal/#filepath-notation","title":"Filepath notation","text":"<p>The notation for filepaths is standardized in the terminals we use. - Your current directory is denoted with <code>./</code> - The parent directory is denoted with <code>../</code> - Your current directory is assumed to be the starting place for your filepaths:  <code>./src/main/main.c</code> is treated the same as <code>src/main/main.c</code>.</p> <p>The paths can be combined to express any file location in your system.</p>"},{"location":"Firmware/Terminal/#examples","title":"Examples","text":"<ul> <li>Relative to the <code>new-project</code> directory, <code>flash.sh</code> is located at <code>./scripts/flash.sh</code> or <code>scripts/flash.sh</code></li> <li>If you are in the <code>scripts</code> directory, <code>main.c</code> is located at <code>../src/main/main.c</code></li> <li>If you are in the <code>driver</code> directory, <code>flash.sh</code> is located at <code>../../scripts/flash.sh</code></li> </ul>"},{"location":"Firmware/Terminal/#tab-completion","title":"Tab Completion","text":"<p>When referencing a command or file on the command line, you can use the <code>tab</code> key to autocomplete your command. If there are multiple valid files or directories that start with the text you wrote, it will display those as options.</p>"},{"location":"Firmware/Terminal/#examples_1","title":"Examples","text":"<ul> <li>To open <code>config.h</code> with <code>vim</code>, you can write <code>vim co&lt;tab&gt;</code>, and it will autofill to <code>vim config.h</code></li> <li>If you run <code>cd s&lt;tab&gt;</code>, the terminal will display both <code>src</code> and <code>scripts</code>, as they are both valid options for your command. If you wrote <code>cd sc&lt;tab&gt;</code> instead, it will autofill to <code>cd scripts</code> as it is the only valid option.</li> </ul>"},{"location":"Firmware/Terminal/#vim","title":"Vim","text":"<p>Vim is a text editor that is built into the terminal. It makes for quick and seamless editing/viewing of files while inside the terminal. While there are many advanced things that can be done with Vim, using it simply is quite easy. Vim is the recommended text editor of the firmware team. Vim can be opened with the <code>vim &lt;filename&gt;</code> command. </p> <p>The idea of vim is that in different modes, the keys do different commands. The two main modes of Vim you will be using are  Normal mode and Insert mode. In Normal mode, the keys will do special things, like navigating around the file. In Insert mode, the keys will behave like a normal keyboard, and will insert directly into your document. From Normal mode, enter Insert mode by pressing the <code>i</code> key. From Insert mode, enter normal mode by pressing the <code>esc</code> key.</p>"},{"location":"Firmware/Terminal/#common-commands-all-in-normal-mode","title":"Common commands (all in Normal mode)","text":"<ul> <li>Save the file with <code>:w</code></li> <li>Quit the file with <code>:q</code></li> <li>Quit the file without saving with <code>:q!</code></li> <li>Search for text in your file with <code>/&lt;text&gt;</code></li> <li>Jump to a line number with <code>:&lt;line_number&gt;</code></li> <li>Jump to the end of a line and enter Insert mode with <code>shift + a</code></li> <li>Copy a line with <code>yy</code></li> <li>Paste with <code>p</code></li> </ul> <p>These are just very simple commands. Vim is an extremely powerful tool, and we encourage you to learn more about how to use it well. There are many resources online for Vim motions and configuration.</p>"},{"location":"Firmware/Terminal/#ls-list","title":"ls (list)","text":"<p>This command will display all of the files in your current directory (folder). It is run standalone, by running <code>ls</code> in your terminal.</p>"},{"location":"Firmware/Terminal/#examples_2","title":"Examples","text":"<p>Running <code>ls</code> inside of the <code>new-project</code> repostory will yield</p> <pre><code>src scripts config.h\n</code></pre> <p><code>src</code> and <code>scripts</code> are directories, <code>config.h</code> is a file.</p>"},{"location":"Firmware/Terminal/#cd-change-directory","title":"cd (change directory)","text":"<p>This command allows you to change the current directory you are in. It is run with the location to go to.</p>"},{"location":"Firmware/Terminal/#examples_3","title":"Examples","text":"<ul> <li>To navigate to the <code>scripts</code> directory from <code>new-project</code>, run <code>cd scripts</code></li> <li>To navigate to the <code>main</code> directory from <code>scripts</code>, run <code>cd ../src/main</code></li> </ul> <p>NOTE: you can only <code>cd</code> into directories, you cannot <code>cd</code> into a file.</p>"},{"location":"Firmware/Terminal/#shbash-run-shell-command","title":"sh/bash (run shell command)","text":"<p>This is the prefix needed to run some shell scripts on some systems. A shell script is a collection of terminal commands that are run after you call the script. It is just a handy way to bundle a common task that has multiple commands. Primarily, the scripts you will be running with this command will  have the suffix <code>.sh</code> or <code>.bash</code>. Depending on the system, you may be able to run a script directly by typing the file's name directly.</p>"},{"location":"Firmware/Terminal/#examples_4","title":"Examples","text":"<ul> <li>To run <code>flash.sh</code> from <code>new-project</code>, run <code>sh scripts/flash.sh</code> or <code>bash scripts/flash.sh</code> or <code>scripts/flash.sh</code></li> </ul>"},{"location":"Firmware/Terminal/#mkdir-make-directory","title":"mkdir (make directory)","text":"<p>This makes a directory. Follow the command with the name of the directory you'd like to make</p>"},{"location":"Firmware/Terminal/#examples_5","title":"Examples","text":"<ul> <li>To make a directory named <code>new-directory</code> run <code>mkdir new-directory</code></li> <li>To make a directory inside the <code>scripts</code> directory, run <code>mkdir scripts/new-directory</code></li> </ul>"},{"location":"Firmware/Terminal/#touch-make-a-new-file","title":"touch (make a new file)","text":"<p>This will create a new file with the name you enter following the <code>touch</code> command.</p>"},{"location":"Firmware/Terminal/#examples_6","title":"Examples","text":"<ul> <li>To make a file <code>notes.md</code> in <code>new-project</code>, run <code>touch notes.md</code></li> </ul>"},{"location":"Hardware/","title":"Hardware","text":"<p>Hardware serves as the physical foundation for all electronic functionality in the car, including\u2014but not limited to\u2014data logging, driver controls, telemetry, and safety features.</p> <p>The car's hardware comprises two main elements:</p> <ul> <li>Printed circuit boards</li> <li>The wiring harness</li> </ul> <ul> <li> <p>Get Started with PCB Design</p> <ul> <li>Get Altium</li> <li>Project Setup</li> <li>Schematic Basics</li> <li>Library</li> <li>PCB Basics</li> <li>Silkscreen Files</li> <li>Export Project</li> </ul> </li> <li> <p>Explore More</p> <ul> <li>MCU</li> <li>Resources</li> </ul> </li> </ul>"},{"location":"Hardware/MCU/","title":"MCU","text":"<p>The Microcontroller Unit (MCU) is the core of our embedded system, managing sensors, actuators, and communication. For the racecar, the MCU handles real-time control and data processing under challenging automotive conditions.</p>"},{"location":"Hardware/MCU/#stm32g473ret6","title":"STM32G473RET6","text":"<p>We use the STM32G473RET6 from STMicroelectronics \u2014 a powerful ARM Cortex-M4 MCU with floating-point support, ideal for control and signal processing tasks.</p> <p>Some documentation on this MCU:</p> <ul> <li> <p>Datasheet</p> </li> <li> <p>Reference Manual for STM32G4 series MCUs</p> </li> <li> <p>Link to part on DigiKey</p> </li> </ul>"},{"location":"Hardware/MCU/#hal","title":"HAL","text":"<p>The Hardware Abstraction Layer (HAL) is a software library provided by STMicroelectronics for STM32 microcontrollers. It offers a high-level, standardized interface to the MCU\u2019s hardware peripherals\u2014such as timers, ADCs, communication interfaces (SPI, I2C, UART), and GPIO\u2014abstracting away the low-level register manipulations.</p> <p>The team's firmware extensively uses the custom Core library, which is largely built on the HAL.</p> <p>HAL Documentation:</p> <ul> <li>HAL Documentation for STM32G4 series MCUs</li> </ul>"},{"location":"Hardware/resources/","title":"Resources","text":"<p>Some resources to explore:</p>"},{"location":"Hardware/resources/#documentation","title":"Documentation","text":"<ul> <li>Altium Designer Documentation</li> </ul>"},{"location":"Hardware/resources/#youtube","title":"YouTube","text":"<ul> <li>Phil's Lab \u2013 Tutorials on PCB layout, signal integrity, and design techniques</li> <li>Altium Academy \u2013 Official channel with Altium design walkthroughs</li> <li>Robert Feranec \u2013 Hardware design tutorials and interviews with experts</li> </ul>"},{"location":"Hardware/Altium/export-project/","title":"Export Project","text":"<p>Once your project is completed, validated, and saved to the server, you can export it. This produces files in the formats expected by the PCB manufacturer (JLCPCB in this case). Specifically, there are two main types:</p> <ul> <li>Gerber: serves as a blueprint for the PCB, providing information on the shape and position of copper traces, silkscreen, and solder mask.</li> <li>NC Drill: provides information about the holes in the PCB, including location, size, depth, plating, and more.</li> </ul>"},{"location":"Hardware/Altium/export-project/#gerber-files","title":"Gerber Files","text":"<ol> <li> <p>Ensure you are in the PCB document in your project.</p> </li> <li> <p>Navigate to File \u2192 Fabrication Outputs \u2192 Gerber Files.</p> <p> </p> </li> <li> <p>In the window that opens, ensure the parameters are as follows:</p> <ol> <li>Units: Inches</li> <li>Decimal: 0.01 (this defines the coordinate precision)</li> </ol> </li> <li> <p>In Plot Layers (at the bottom) choose Select All to ensure that every layer is included in the export.</p> <p> </p> </li> <li> <p>Switch to the Advanced Settings tab at the top and ensure the parameters are set as follows:</p> <ul> <li>Leading/Trailing Zeroes: Suppress leading zeroes (reduces file size).</li> <li>Plotter Type: Unsorted (faster).</li> <li>Others: Use software arcs.</li> </ul> </li> <li> <p>Once all settings are verified, select Apply.</p> <p> </p> </li> <li> <p>The generated CAMTastic file will open. Rename this file to \"Gerber\".</p> <p> </p> </li> <li> <p>Navigate to the generated output files on your system. This path should be Users \u2192 Public \u2192 Public Documents \u2192 Altium \u2192 Your project \u2192 Project Outputs. Inside this folder, create a new folder named \"Gerber\". Move all the files into this folder.</p> <p> </p> </li> </ol> <p>That's the Gerber export complete.</p>"},{"location":"Hardware/Altium/export-project/#nc-drill-files","title":"NC Drill Files","text":"<ol> <li> <p>Return to the PCB document in Altium and navigate to File \u2192 Fabrication Outputs \u2192 NC Drill Files.</p> <p> </p> </li> <li> <p>In the setup window that pops up, ensure the following parameters are selected:</p> <ul> <li>Units: Inches</li> <li>Format: 2:4</li> <li>Leading/Trailing Zeroes: Suppress trailing zeroes</li> <li>Coordinate Positions: Reference to relative origin</li> <li>Other: Optimize change location commands</li> </ul> </li> <li> <p>Select OK.</p> <p> </p> </li> <li> <p>The Import Drill Data window will pop up. Select OK here as well.</p> </li> <li> <p>As before, a generated CAMtastic file will open. Rename this file to \"Drill\".</p> </li> <li> <p>Navigate to the same Project Outputs folder in your file system (Users \u2192 Public \u2192 Public Documents \u2192 Altium \u2192 Your project \u2192 Project Outputs).</p> </li> <li> <p>Create a new folder named \"Drill\" and place all the new files there.</p> <p> </p> </li> </ol>"},{"location":"Hardware/Altium/export-project/#file-compression","title":"File Compression","text":"<ol> <li> <p>Create a third folder in the same Project Outputs directory (Users \u2192 Public \u2192 Public Documents \u2192 Altium \u2192 Your project \u2192 Project Outputs) named the same as the title of your project on Altium.</p> </li> <li> <p>Move the Gerber and Drill folders into this new folder. Compress this folder. (On Windows: right-click and select Compress to \u2192 ZIP file.)</p> </li> </ol> <p>This ZIP file is your final output which can be sent by the Electronics Lead to JLCPCB for manufacturing.</p>"},{"location":"Hardware/Altium/get-altium/","title":"Get Altium","text":"<p>Altium Designer is a powerful, industry-leading PCB (Printed Circuit Board) design software used by the Electronics team at RIT Racing to create and develop complex circuit boards for the car\u2019s electrical systems.</p> <p>To get a free student license and download Altium, follow these steps:</p> <ol> <li> <p>Follow this link: https://education.altium.com/</p> </li> <li> <p>Click Enroll for Free and sign up with your school email (e.g., abc1234@rit.edu \u2014 do not use @g.rit.edu). You will need to verify your academic status by filling out some information when prompted.</p> <p> </p> </li> <li> <p>After signing up, you can download and install Altium Designer.</p> <p> </p> </li> <li> <p>You should receive an email through which you can activate your account (it may take a little while to arrive).</p> <p> </p> </li> <li> <p>On the downloads page, you can get the latest version of Altium Designer:</p> <p> </p> </li> <li> <p>After downloading, open the setup.exe file and follow the installation steps. You will be asked to sign in and select features. Check all the boxes to ensure full functionality:</p> <p> </p> </li> <li> <p>Choose a location in your file system to install the software and documents. You can leave it as the default location.</p> </li> <li> <p>Once installation is complete, sign in to your Altium account.</p> <p> </p> </li> <li> <p>Activate your license.</p> <p> </p> </li> </ol> <p>You now have Altium Designer installed and ready to use with your student license.</p>"},{"location":"Hardware/Altium/library/","title":"Library","text":"<p>In Altium, libraries store all components used in schematic and PCB designs\u2014including symbols, footprints, and part numbers.</p> <p>The New Library contains a collection of commonly used components for team projects. Components can be selected from this library or added if they aren\u2019t already available. This ensures consistent symbols, footprints, and part data across all designs.</p>"},{"location":"Hardware/Altium/library/#use-existing-components","title":"Use Existing Components","text":"<p>To add components from the library:</p> <ol> <li> <p>Click the Panels button on the bottom right corner and go to Explorer. In the window that pops up, navigate to Components \u2192 New_Library and click on Components. A list should appear in the section on the right.</p> <p> </p> </li> <li> <p>The folder is further split into different component types (eg., resistors, capacitors, ICs, etc.) Each component has a name and description listed. When selected, details of the component appear in the panel below. This includes footprints of the parts associated with the component.</p> <p> </p> </li> <li> <p>Right-click \u2192 Place or drag the component onto the schematic.</p> </li> </ol>"},{"location":"Hardware/Altium/library/#add-a-new-component","title":"Add a New Component","text":"<ol> <li>Search for the part you need on Digikey.</li> <li>In Altium, navigate to the Explorer panel and to New_Library \u2192 Components \u2192 [appropriate component type].</li> <li> <p>Click Add Component in the top right.</p> <p> </p> </li> <li> <p>Add the component name and manufacturer part number (under Parameters) to the sections on the left.</p> <p> </p> </li> </ol>"},{"location":"Hardware/Altium/library/#creating-footprints-and-symbols","title":"Creating Footprints and Symbols","text":""},{"location":"Hardware/Altium/library/#common-packages","title":"Common Packages","text":"<p>For creating footprints for packages which are commonly used (e.g., SOIC-8, SOT-23, etc.):</p> <ol> <li>Navigate go to Add Footprint \u2192 Wizard.</li> <li>Choose the package type.</li> <li>Refer to the component\u2019s datasheet for mechanical dimensions and input these into the wizard.</li> <li>After creating the footprint, pair it with the appropriate schematic symbol from the existing ones in the library.</li> <li>Name the component using the part number. Altium will prompt you to autofill parameters based on the symbol and footprint\u2014this is recommended for all parts except basic resistors and capacitors.</li> </ol>"},{"location":"Hardware/Altium/library/#uncommon-packages","title":"Uncommon Packages","text":"<p>Note: The following images demonstrate using a common part which would otherwise be added using the above steps.</p> <p>Follow the steps below for uncommon packages or unique parts for which the footprint must be imported.</p> <ol> <li> <p>In the Digikey product page, locate the EDA/CAD Models section.</p> <p> </p> </li> <li> <p>Choose a download option compatible with Altium (e.g., Ultra Librarian).</p> <p> </p> </li> <li> <p>Select Altium as the download format (no need to select 3D CAD model).</p> <p> </p> </li> <li> <p>Extract the downloaded ZIP file to a known location on your computer.</p> </li> <li> <p>On Altium go to File \u2192 Run Script.</p> <p> </p> </li> <li> <p>A window will pop up. Here, select Browse \u2192 From file.</p> <p> </p> </li> <li> <p>Select the file (it should begin with \"UL_Import\").</p> <p> </p> </li> <li> <p>Select the one that says UL_Form.</p> <p> </p> </li> <li> <p>In the UL Import window that pops up, select File and choose the text document from the extracted files.</p> <p> </p> </li> <li> <p>The component documents should appear in the left panel under your open projects. (For files ending in \".PcbDoc\": if the content appears blank, try closing and reopening the document.)</p> </li> <li> <p>For both the symbol and footprint:</p> <ol> <li>Select Wizard \u2192 New.</li> <li>Copy and paste the symbol/footprint from the respective files.</li> </ol> <p> </p> <p> </p> </li> </ol>"},{"location":"Hardware/Altium/library/#finishing-up","title":"Finishing Up","text":"<ol> <li>Right-click on the new component tab and Save.</li> <li>Save to Server.</li> <li> <p>When creating or editing a component, be sure to add a comment such as \"Created/Edited on [current date]\" along with a description of the additions or changes in the Release Notes window that appears.</p> <p> </p> </li> </ol>"},{"location":"Hardware/Altium/pcb-basics/","title":"PCB Basics","text":"<p>After creating the schematic, you can move on to designing the PCB. Good PCB design minimizes noise, ensures reliable connections, and balances performance with manufacturability. To start with, focus on keeping layouts simple and organized.</p>"},{"location":"Hardware/Altium/pcb-basics/#setup","title":"Setup","text":"<ol> <li>When laying out the PCB, first ensure that the completed schematic has been validated as necessary.</li> <li>If you haven't done so already, you should add a PCB document to the project.</li> </ol>"},{"location":"Hardware/Altium/pcb-basics/#layers","title":"Layers","text":""},{"location":"Hardware/Altium/pcb-basics/#the-stackup","title":"The Stackup","text":"<p>A PCB contains multiple layers, each of which serves a different purpose. The configuration this is known as the layer stackup. The team's PCBs often use 4 layers:</p> <ul> <li> <p>Top Layer (Signal) \u2013 This is where the main routing and component placement is.</p> </li> <li> <p>Inner Layer 1 (Ground Plane) \u2013 A solid ground for signal return paths and EMI (electromagnetic interference) control.</p> </li> <li> <p>Inner Layer 2 (Power Plane) \u2013 Distributes power across the circuit (e.g., 5V, 3.3V).</p> </li> <li> <p>Bottom Layer (Signal) \u2013 For secondary routing or ground fill; also used for components in dense layouts.</p> </li> </ul> <p>Some boards may require different layer configurations depending on complexity or signal requirements. This should be kept in mind before starting layout.</p>"},{"location":"Hardware/Altium/pcb-basics/#access-and-edit-layers","title":"Access and Edit Layers","text":"<ol> <li> <p>To access the layer stack, navigate to Design \u2192 Layer Stack Manager.</p> <p> </p> </li> <li> <p>The default layer stack on Altium does not have the ground and power planes. Instead, it just has two signal layers (in yellow): </p> <p> </p> </li> <li> <p>The configuration described earlier can be seen here in the New Member Board stackup. To create this, simply add and edit the required planes:</p> <p> </p> </li> <li> <p>Once the layers have been set up, you can return to the main PCB document.</p> </li> </ol>"},{"location":"Hardware/Altium/pcb-basics/#components","title":"Components","text":"<ol> <li> <p>The schematic is used to initialize and update the components on the PCB. This can be done by selecting Design \u2192 Update PCB Document at the top.</p> <p> </p> </li> <li> <p>A window will open with the list of components to be updated. The checkboxes on the left indicate whether a particular component should be updated based on the PCB. By default, these should all be checked.</p> <p> </p> </li> <li> <p>After confirming that everything is in order, you can proceed with executing the changes. The default footprints of each component will appear in an arbitrary position on the PCB. These are connected with light lines indicating the net.</p> <p> </p> </li> <li> <p>Bring the components onto the board by clicking and dragging them, and begin to lay them out. </p> </li> </ol> <p>There are a number of things to keep in mind when coming up with a particular layout, but the general idea is that the component positioning should be logical, with the nets and routing in mind.</p>"},{"location":"Hardware/Altium/pcb-basics/#routing","title":"Routing","text":"<p>There are a number of ways to route connections on a PCB:</p> <ul> <li>Trace</li> <li>Polygon pour</li> <li>Via (for connecting layers)</li> </ul>"},{"location":"Hardware/Altium/pcb-basics/#trace","title":"Trace","text":"<p>A trace represents a wire\u2014the simplest connection between components. To draw a trace:</p> <ol> <li> <p>Select Interactive Routing from the toolbar. The short-cut for this is Ctrl+W (as with drawing a wire in the schematic). Optionally, you can adjust the settings for interactive routing to disable automatic rule-based corrections.</p> <p> </p> </li> <li> <p>Click where you want to start your trace. If you start on a component, the trace will automatically inherit that component\u2019s net.</p> </li> <li> <p>Move your cursor to extend the trace and click again where you want the end point of that straight-line segment. </p> <p> </p> </li> <li> <p>Press Esc to leave it there or continue by extending a second segment in the same way. Press Backspace to remove the last vertex.</p> </li> </ol>"},{"location":"Hardware/Altium/pcb-basics/#polygon-pour","title":"Polygon Pour","text":"<p>A polygon pour is a solid copper object, which has greater surface area than a wire. This can be beneficial for a number of reasons (e.g., lower impedance and better heat dissipation).</p> <p>To draw a polygon pour:</p> <ol> <li> <p>Select Polygon Pour from the toolbar.</p> <p> </p> </li> <li> <p>Click where you want the starting vertex to be.</p> </li> <li>Press Shift+Space to toggle between different corner angle modes.</li> <li> <p>Move your cursor to extend an edge and click again to create another vertex. You can create as many vertices as desired and press Backspace to remove the last vertex.</p> <p> </p> </li> <li> <p>Press Esc to complete the object. Ensure all corners are closed; otherwise, the polygon may not generate properly.</p> </li> <li>To attach the polygon to a net, select the polygon and select it from the Net section of the Properties panel.</li> <li> <p>The Pour Over Same Net section in the Properties panel determines how the polygon interacts with other objects in the same net.</p> <p> </p> </li> <li> <p>To ensure that the polygon remains intact after any modifications are made, enable Repour All at the top in Tools \u2192 Polygon Pours.</p> <p> </p> </li> </ol>"},{"location":"Hardware/Altium/pcb-basics/#via","title":"Via","text":"<p>A via is a connection between different layers of a board. There are 3 types of vias:</p> <ul> <li>Through-hole (1)</li> <li>Blind (2)</li> <li>Buried (3)</li> </ul> <p></p> <p>On the team, we exclusively use through-hole vias. To add a via:</p> <ol> <li> <p>Select Via from the toolbar.</p> <p> </p> </li> <li> <p>Move the mouse to position the via. You can press the Alt key to restrict vertical or horizontal movement (this may be useful for alignment). Click to place in the desired position.</p> <p> </p> </li> <li> <p>Assign a net to the via in the Properties panel.</p> <p> </p> </li> <li> <p>Alternatively, vias can be auto-placed by pressing 2 while routing.</p> </li> </ol>"},{"location":"Hardware/Altium/pcb-basics/#board-shape","title":"Board Shape","text":"<p>Defining the board shape is an important step in the PCB design process. The following shows an empty board, but this can also be done after placing components and completing routing.</p> <p>One way to define the board shape is by using a predefined outline:</p> <ol> <li> <p>First, draw the shape of the board as you like using primitives (i.e. lines, arcs, shapes) on a mechanical layer.</p> </li> <li> <p>After ensuring the shape follows the border region you intend, go to Design \u2192 Board Shape \u2192 Define Board Shape from Selected Objects.</p> <p> </p> </li> <li> <p>Alternatively, you can define/edit the board shape by pressing the 1 key, and going to Design:</p> </li> </ol>"},{"location":"Hardware/Altium/pcb-basics/#design-rule-checker","title":"Design Rule Checker","text":"<p>To confirm that the design conforms to rules, you must do a Design Rule Check, which checks all elements of the PCB against the enabled design rules. This includes constraints like minimum trace width, clearance, and routing violations.</p> <ol> <li> <p>Go to Tools \u2192 Design Rule Check.</p> <p> </p> </li> <li> <p>You can edit settings as necessary, both for the report file and the rules being checked.</p> </li> <li> <p>Run Design Rule Check.</p> <p> </p> </li> <li> <p>A window should appear with messages describing any violations.</p> <p> </p> </li> </ol>"},{"location":"Hardware/Altium/pcb-basics/#silkscreen","title":"Silkscreen","text":"<p>The silkscreen is a layer of the board that contains labeling and graphics. These are not linked to the circuit itself, but provide important information about the board like the name and revision. On Altium, this is the Top and Bottom Overlay.</p>"},{"location":"Hardware/Altium/pcb-basics/#labels","title":"Labels","text":"<ol> <li> <p>Text can be added to the silkscreen by going to the toolbar and selecting Place \u2192 String.</p> </li> <li> <p>The + and - keys cycle through which layer the string is placed on.</p> </li> </ol> <p>By default, all components on the PCB are labeled with the component designators, the formatting of which can be modified. In general, a few specific changes help improve readability and consistency:</p>"},{"location":"Hardware/Altium/pcb-basics/#truetype-text","title":"TrueType Text","text":"<ol> <li>Select one of the labels and right-click.</li> <li>On the menu, select Find Similar Objects and OK. This should select all of the component labels.</li> <li> <p>In the Properties panel, select TrueType in the Font section.</p> <p> </p> </li> <li> <p>Depending on the use, you may choose to make the text inverted (particularly for the text you want to make stand out).</p> </li> </ol>"},{"location":"Hardware/Altium/pcb-basics/#images","title":"Images","text":"<p>Most boards will also require graphics, like the RIT Racing logo. Files for commonly used graphics can be found on the Silkscreen Files page. </p> <ol> <li>Download the desired image if you don't have it already.</li> <li>On the PCB document, select the appropriate overlay layer (Top Overlay or Bottom Overlay) before placing the image.</li> <li> <p>Go to Place \u2192 Graphics.</p> <p> </p> </li> <li> <p>Drag to select the space you want the graphic to occupy.</p> </li> <li> <p>A window will open showing your file system. Select the image you want to use.</p> <p> </p> <p> </p> </li> <li> <p>The graphic should appear as part of the silkscreen.</p> </li> </ol>"},{"location":"Hardware/Altium/pcb-basics/#further-reading","title":"Further Reading","text":"<p>This is just a brief introduction to PCB design.</p> <p>For more specifics and questions, look at the Resources page, where you can find links to explore all of Altium's features and capabilities as well as general knowledge about PCBs.</p>"},{"location":"Hardware/Altium/project-setup/","title":"Project Setup","text":""},{"location":"Hardware/Altium/project-setup/#new-project","title":"New Project","text":"<ol> <li> <p>In the toolbar at the top, navigate to File \u2192 New \u2192 Project.</p> <p> </p> </li> <li> <p>A window will open where you can set the project's name, its local path, and its location on the RIT Racing server. After confirming, click Save.</p> <p> </p> </li> </ol>"},{"location":"Hardware/Altium/project-setup/#add-schematic","title":"Add Schematic","text":"<ol> <li> <p>Once the project loads, add a schematic: right-click on the project name and select Add New to Project \u2192 Schematic.</p> <p> </p> </li> <li> <p>A blank schematic will appear. </p> </li> <li> <p>You'll notice an asterisk (*) and a red symbol next to the project name. This indicates that changes have been made but not yet saved to the server. To push the changes, click Save to Server.</p> </li> <li> <p>The first time you save, you'll be asked to choose a local location. You can usually accept the default path, which will typically look llike this:</p> <p> </p> </li> <li> <p>After saving locally, a window will display the modified files. You can choose which updates to push to the server (all are selected by default). Uncheck any files you don\u2019t want to include, then click OK.</p> <p> </p> </li> <li> <p>The title block on the schematic displays key information like board name, author, revision number, and date. This information can be edited in Properties \u2192 Title Block</p> </li> </ol>"},{"location":"Hardware/Altium/project-setup/#add-pcb-document","title":"Add PCB Document","text":"<ol> <li> <p>To add a PCB design to the project, right-click on the project and go to Add New to Project \u2192 PCB.</p> <p> </p> </li> <li> <p>A blank PCB document will appear. The bar at the bottom shows the different available layers. Once your schematic is complete, you can update this design with components.</p> <p> </p> </li> </ol>"},{"location":"Hardware/Altium/project-setup/#design-rules","title":"Design Rules","text":"<p>To maintain consistency and ensure that designs conform to technical requirements, a standardized set of PCB design rules has to be imported to Altium for use in the team's projects. This is a .RUL file that will be provided to you. </p> <p>To import:</p> <ol> <li>Go to Design \u2192 Rules in the top menu.</li> <li>In the PCB Rules and Constraints Editor, right-click on the Design Rules folder on the top left and select Import Rules.</li> <li>The Choose Design Rule Type panel will open. Select all (Ctrl+A) and click OK.</li> <li>Browse to the .RUL file and select it.</li> <li>Click Open.</li> </ol>"},{"location":"Hardware/Altium/schematic-basics/","title":"Schematic Basics","text":"<p>After setting up your project, you can begin designing the schematic. This acts as a blueprint of the circuit. Once it's created and validated, Altium can use it to populate and update the PCB with components.</p>"},{"location":"Hardware/Altium/schematic-basics/#adding-symbols","title":"Adding Symbols","text":"<ol> <li> <p>Choose a part from the components library.</p> </li> <li> <p>Right-click on the part and select Place. If the component has multiple parts, you will have to choose one.</p> </li> <li> <p>The symbol will appear translucent. Position it by hovering the mouse over the desired position and click to place. Right-click or Esc to cancel. After placing the symbol, rotate it by selecting it and pressing Space.</p> <p> </p> </li> <li> <p>Once placed, you can select the symbol and go to the Properties panel to access details.</p> </li> </ol>"},{"location":"Hardware/Altium/schematic-basics/#annotating-the-schematic","title":"Annotating the Schematic","text":"<p>A component is labeled using a designator which can be edited in the Properties tab. The prefix (letter) is based on the type of part, and the number distinguishes it from other components of the same type.</p> <p>These are some common components:</p> <ul> <li>R - Resistor </li> <li>C - Capacitor</li> <li>L - Inductor</li> <li>K - Relay</li> <li>Q - Transistor</li> <li>TP - Test Point</li> <li>U - Integrated Circuit</li> </ul> <p></p> <p>To automatically annotate components:</p> <ol> <li>To to Tools \u2192 Annotate Schematics Quietly.</li> <li>To undo or redo the annotation, you can go to Tools \u2192 Annotate Schematics which allows more fine-tuned control.</li> </ol> <p>Alternatively, components can be manually batch-annotated by type:</p> <ol> <li>Right-click on any one placed component (e.g., a resistor).</li> <li>Select Find Similar Objects.</li> <li>In the window, set Designator and Kind as Same.</li> <li>Click OK \u2014 this selects all similar parts (e.g., all resistors).</li> <li>Go to Tools \u2192 Annotate Schematics Quietly.</li> </ol>"},{"location":"Hardware/Altium/schematic-basics/#connecting-parts","title":"Connecting Parts","text":"<p>Components in a schematic are connected together with a net. This can be indicated either by physically wiring them together or assigning a net label. </p>"},{"location":"Hardware/Altium/schematic-basics/#wire","title":"Wire","text":"<p>A wire can be drawn by right-click and select Place \u2192 Wire, or more easily, with Ctrl+W.</p> <p>Hover to position and click at the connecting pin to attach. Then click on the other component where it should connect. The wire adjusts when the component is moved.</p>"},{"location":"Hardware/Altium/schematic-basics/#net","title":"Net","text":"<p>All connected components are part of the same net. In a schematic, you can indicate that a component is part of a particular net, even if it appears separate, by placing a net label.</p> <p>Connect a short bit of wire to the desired pin. Then, similar to placing the wire, right-click and select Place \u2192 Net Label. This should be connected to the end of the wire, and the text edited to indicate which net it is a part of.</p>"},{"location":"Hardware/Altium/schematic-basics/#port","title":"Port","text":"<p>A port makes a connection between multiple sheets of a schematic. The name of the port on one sheet corresponds to the name of the port on the other sheet to which it connects. It is placed the same way as a wire or net label.</p> <p>A power port specifically indicates a connection to a power or ground net.</p>"},{"location":"Hardware/Altium/schematic-basics/#validation","title":"Validation","text":"<p>Once the schematic is complete, it needs to be validated to check for any errors. Validation must be completed before generating the PCB layout.</p> <p>To do this, go to Project \u2192 Validate Project.</p> <p>Errors or warnings in the schematic design will appear in the Messages panel. Some can be ignored, but others indicate issues that need to be resolved. In this example, a wire has been removed to demonstrate the resulting errors that must be corrected:</p>"},{"location":"Hardware/Altium/silkscreen-files/","title":"Silkscreen Files","text":"<ul> <li> <p>Fastest Club in Rochester</p> <p></p> <p>Download PNG</p> </li> <li> <p>RIT Racing Logo</p> <p></p> <p>Download PNG</p> </li> <li> <p>High Voltage Symbol</p> <p></p> <p>Download PNG</p> </li> <li> <p>Adding the Graphics</p> <p>Find instructions on how to put the images as graphics on your PCB design here.</p> </li> </ul>"}]}